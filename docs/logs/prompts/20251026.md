# Trading Engine Development Plan - 2025-10-26

## Context

The Portfolio and Orders modules are now complete and tested. The Trading Engine is the next critical component, serving as the execution layer that connects order submission to trade generation and portfolio updates.

### Completed Dependencies âœ…

- **Orders Module**: Full CRUD, validation, status management (13 tests passing)
- **Portfolio Module**: Lot tracking, FIFO/AverageCost, P&L calculations (42 tests passing)
- **Base Types**: Core domain models including `trade` type already defined

### Current State ðŸš§

- **Engine Module**: Scaffolded only (bin/, test/, README.md exist)
- No implementation files yet

## Architecture Clarification

### Key Discovery: Trade Type Already Exists

The `trade` type is **already defined** in `trading/base/lib/types.mli`:

```ocaml
type trade = {
  id : string;
  order_id : string;
  symbol : symbol;
  side : side;
  quantity : quantity;
  price : price;
  commission : float;
  timestamp : Time_ns_unix.t;
}
```

**Implication**: Engine doesn't define trades, it **generates** them from order execution.

### Engine Responsibilities

1. **Execute Orders**: Convert orders into trades based on market conditions
2. **Market Simulation**: Provide realistic price discovery and liquidity
3. **Validation**: Ensure orders can be executed given portfolio constraints
4. **Reporting**: Generate execution reports showing fill details

### Data Flow

```
Simulation/Strategy â†’ Orders â†’ Engine â†’ Trades â†’ Portfolio
                                  â†‘
                            Market Data
```

## Development Strategy

### Phase 1: Core Types and Market Data (Week 1)

**Goal**: Define engine-specific types and basic market data structures

#### Files to Create

- `trading/engine/lib/types.mli`
- `trading/engine/lib/types.ml`
- `trading/engine/test/test_types.ml`

#### Core Types Needed

1. **Market Data**

```ocaml
type market_data = {
  symbol : symbol;
  bid : price option;
  ask : price option;
  last : price option;
  timestamp : Time_ns_unix.t;
}

type market_state = {
  prices : (symbol, market_data) Hashtbl.t;
  (* Future: order book, depth, etc. *)
}
```

2. **Execution Report**

```ocaml
type fill_status = Filled | PartiallyFilled | Unfilled
[@@deriving show, eq]

type execution_report = {
  order_id : string;
  status : fill_status;
  filled_quantity : quantity;
  remaining_quantity : quantity;
  average_price : price option;
  trades : trade list;  (* Generated trades *)
  timestamp : Time_ns_unix.t;
}
```

3. **Engine Configuration**

```ocaml
type commission_config = {
  per_share : float;
  minimum : float;
}

type engine_config = {
  commission : commission_config;
  (* Future: slippage, market impact, etc. *)
}
```

#### Testing

- Test type construction and derivations
- Test equality and show functions
- **Success Criteria**: Types compile, tests pass

---

### Phase 2: Simple Market Data Management (Week 1-2)

**Goal**: Basic market data storage and retrieval

#### Files to Create

- `trading/engine/lib/market.mli`
- `trading/engine/lib/market.ml`
- `trading/engine/test/test_market.ml`

#### Functions to Implement

```ocaml
(* Create empty market state *)
val create : unit -> market_state

(* Update price for a symbol *)
val update_price : market_state -> symbol -> bid:price -> ask:price -> last:price -> unit

(* Get current market data *)
val get_market_data : market_state -> symbol -> market_data option

(* Get last trade price (for market orders) *)
val get_last_price : market_state -> symbol -> price option
```

#### Implementation Notes

- Use `Hashtbl` for O(1) lookups
- Simple in-memory storage initially
- No persistence needed yet
- Thread safety not required (single-threaded simulation)

#### Testing Strategy

- Create market state
- Update prices for multiple symbols
- Retrieve and verify data
- Handle missing symbols gracefully
- **Success Criteria**: 10-15 tests passing

---

### Phase 3: Market Order Execution (Week 2-3)

**Goal**: Implement market order execution with proper variant dispatch

#### Files to Create

- `trading/engine/lib/execution.mli`
- `trading/engine/lib/execution.ml`
- `trading/engine/test/test_execution.ml`

#### Public Interface (execution.mli)

```ocaml
(* Execute a single order - dispatches on order_type variant *)
val execute_order :
  engine_config ->
  market_state ->
  order ->
  execution_report status_or

(* Execute multiple orders *)
val execute_orders :
  engine_config ->
  market_state ->
  order list ->
  execution_report list status_or
```

#### Implementation (execution.ml)

```ocaml
(* Private: Execute market order *)
let _execute_market_order config market order =
  (* Implementation here *)
  ...

(* Public: Dispatch based on order_type variant *)
let execute_order config market order =
  match order.order_type with
  | Market -> _execute_market_order config market order
  | Limit _ | Stop _ | StopLimit _ ->
      error_invalid_argument "Order type not yet supported"
```

#### Algorithm (_execute_market_order)

1. Get last price from market_state for symbol
2. Calculate commission using engine_config
3. Generate trade with:
   - Unique trade ID
   - Order ID reference
   - Symbol, side, quantity from order
   - Execution price = last price
   - Calculated commission
   - Current timestamp
4. Create execution_report with Filled status
5. Return Result.Ok or Error if invalid

#### Error Cases

- No market data available for symbol
- Order type is not Market (handled by dispatch)
- Missing last price in market data

#### Testing Strategy

- Execute buy market order through public `execute_order`
- Execute sell market order
- Commission calculations
- Missing market data error
- Non-market orders return "not yet supported" error
- Multiple orders in batch via `execute_orders`
- **Success Criteria**: 15-20 tests passing

---

### Phase 4: Limit Order Execution (Week 3-4)

**Goal**: Add limit order support to the execution dispatch

#### Extend Execution Module (execution.ml)

```ocaml
(* Private: Execute limit order if price condition met *)
let _execute_limit_order config market order limit_price =
  (* Implementation here *)
  ...

(* Private: Check if limit order can be filled *)
let _can_fill_limit_order market order limit_price =
  (* Helper function *)
  ...

(* Public: Updated dispatch with limit support *)
let execute_order config market order =
  match order.order_type with
  | Market -> _execute_market_order config market order
  | Limit limit_price -> _execute_limit_order config market order limit_price
  | Stop _ | StopLimit _ ->
      error_invalid_argument "Order type not yet supported"
```

#### Algorithm (_execute_limit_order)

1. Check fill condition using bid/ask from market_state:
   - Buy limit: ask price <= limit price
   - Sell limit: bid price >= limit price
2. If fillable:
   - Execute at limit price (or better if available)
   - Generate trade
   - Return Filled report
3. If not fillable:
   - Return Unfilled report with empty trades list

#### Testing Strategy

- Buy limit fills when ask <= limit (test via `execute_order`)
- Sell limit fills when bid >= limit
- Buy limit unfilled when ask > limit
- Sell limit unfilled when bid < limit
- Price improvement scenarios
- Missing market data
- Mixed market and limit orders in `execute_orders`
- **Success Criteria**: 30-35 cumulative tests passing

---

### Phase 5: Stop Order Execution (Week 4)

**Goal**: Add stop order support to the execution dispatch

#### Extend Execution Module (execution.ml)

```ocaml
(* Private: Check if stop order should trigger *)
let _should_trigger_stop market order side stop_price =
  (* Helper function *)
  ...

(* Private: Execute stop order (converts to market) *)
let _execute_stop_order config market order stop_price =
  (* Implementation here *)
  ...

(* Public: Updated dispatch with stop support *)
let execute_order config market order =
  match order.order_type with
  | Market -> _execute_market_order config market order
  | Limit limit_price -> _execute_limit_order config market order limit_price
  | Stop stop_price -> _execute_stop_order config market order stop_price
  | StopLimit _ ->
      error_invalid_argument "StopLimit orders not yet supported"
```

#### Algorithm (_execute_stop_order)

1. Get last price from market_state
2. Check trigger condition:
   - Buy stop: last price >= stop price
   - Sell stop: last price <= stop price
3. If triggered:
   - Convert to market order
   - Execute at current last price (with optional slippage)
   - Generate trade
   - Return Filled report
4. If not triggered:
   - Return Unfilled report with empty trades list

#### Testing Strategy

- Stop orders trigger correctly based on price
- Stop orders remain unfilled when not triggered
- Stop-to-market conversion behavior
- Missing market data handling
- Mixed order types (market, limit, stop) in batch
- **Success Criteria**: 45-50 cumulative tests passing

---

### Phase 6: Portfolio Integration (Week 5)

**Goal**: Validate orders against portfolio, apply trades

#### Files to Create

- `trading/engine/lib/engine.mli`
- `trading/engine/lib/engine.ml`
- `trading/engine/test/test_engine.ml`

#### Core Engine Type

```ocaml
type t = {
  config : engine_config;
  market : market_state;
}

(* Create engine *)
val create : engine_config -> t

(* Update market prices *)
val update_market : t -> symbol -> bid:price -> ask:price -> last:price -> unit

(* Execute order with portfolio validation *)
val execute_with_portfolio :
  t ->
  Portfolio.t ->
  order ->
  (execution_report * Portfolio.t) status_or

(* Execute multiple orders, updating portfolio after each *)
val execute_orders_with_portfolio :
  t ->
  Portfolio.t ->
  order list ->
  (execution_report list * Portfolio.t) status_or
```

#### Algorithm (execute_with_portfolio)

1. Validate order can be executed (market data exists)
2. **For buy orders**: Check portfolio has sufficient cash
   - Calculate max cost: quantity \* price + commission
   - Use `Portfolio.get_cash` to check balance
   - Return error if insufficient
3. **For sell orders**: Check portfolio has sufficient position
   - Use `Portfolio.get_position` to check holdings
   - Return error if insufficient quantity
4. Execute order using execution module
5. If execution successful, apply trades to portfolio
   - Use `Portfolio.apply_trades` with generated trades
6. Return (execution_report, updated_portfolio)

#### Testing Strategy

- Execute buy with sufficient cash âœ“
- Execute buy with insufficient cash âœ—
- Execute sell with sufficient position âœ“
- Execute sell with insufficient position âœ—
- Multiple orders updating portfolio sequentially
- Portfolio cash/position validation
- Trade application and P&L tracking
- **Success Criteria**: 20-25 tests passing

---

## Implementation Guidelines

### TDD Workflow (Per Phase)

1. **Design**: Write `.mli` interface with detailed comments
2. **Build**: Create stub `.ml` with minimal implementation (`failwith "not implemented"`)
3. **Test**: Write comprehensive test suite
4. **Implement**: Make tests pass one by one
5. **Review**: Self-critique for clarity and edge cases
6. **Format**: Run `dune fmt`
7. **Commit**: Small, focused commit message

### Code Quality Checklist

- [ ] All public functions documented in `.mli`
- [ ] Use Result types for operations that can fail
- [ ] Validation before execution
- [ ] Helper functions prefixed with `_`
- [ ] Pattern matching is exhaustive
- [ ] Tests use Matchers library for assertions
- [ ] Error messages are descriptive
- [ ] No magic numbers (use named constants)

### Testing Principles

- Test both success and error cases
- Use descriptive test names and messages
- Build on Matchers library (`assert_ok_with`, `assert_error`, etc.)
- Create test data builders with sensible defaults
- Keep tests independent and isolated
- Aim for >90% code coverage

### Common Patterns

**Variant Dispatch Pattern** (public interface):

```ocaml
(* Public function dispatches on order_type variant *)
let execute_order config market order =
  match order.order_type with
  | Market -> _execute_market_order config market order
  | Limit limit_price -> _execute_limit_order config market order limit_price
  | Stop stop_price -> _execute_stop_order config market order stop_price
  | StopLimit _ -> error_invalid_argument "StopLimit not supported"
```

**Error Handling** (private implementation):

```ocaml
let _execute_market_order config market order =
  let open Result.Let_syntax in
  let%bind market_data = _get_market_data market order.symbol in
  let%bind last_price = _extract_last_price market_data in
  let commission = _calculate_commission config order in
  let trade = _generate_trade config order last_price commission in
  return (_create_execution_report order [trade] Filled)
```

**Validation Pattern**:

```ocaml
let _validate_order order =
  let validations = [
    _validate_symbol order.symbol;
    _validate_positive_quantity order.quantity;
  ] in
  combine_status_list validations
```

## Success Metrics

### Phase Completion Criteria

- [ ] Phase 1: Types compile, 5+ tests pass
- [ ] Phase 2: Market data management, 15+ tests pass
- [ ] Phase 3: Market orders execute, 20+ cumulative tests pass
- [ ] Phase 4: Limit orders execute, 35+ cumulative tests pass
- [ ] Phase 5: Stop orders execute, 50+ cumulative tests pass
- [ ] Phase 6: Portfolio integration, 75+ cumulative tests pass

### Overall Success

- [ ] All 6 phases complete
- [ ] 75+ tests passing (minimum)
- [ ] Clean interfaces with comprehensive documentation
- [ ] Integration with Portfolio and Orders modules working
- [ ] Proper variant dispatch pattern used throughout
- [ ] Zero compilation warnings
- [ ] Code formatted with `dune fmt`

## Known Challenges

1. **Trade ID Generation**: Need deterministic IDs for testing

   - Solution: Accept optional ID generator function

2. **Timestamp Management**: Tests need deterministic time

   - Solution: Accept optional timestamp function parameter

3. **Commission Calculation**: Edge cases with fractional shares

   - Solution: Clear rounding rules, document in comments

4. **Slippage Modeling**: Complex for realistic simulation

   - Solution: Start simple (fixed percentage), enhance later

5. **Order Book**: Not implementing full order book initially
   - Solution: Simple last/bid/ask model, enhance in future

## Future Enhancements (Post-MVP)

- Partial fills for large orders
- Market impact modeling
- Time-in-force handling (DAY, GTC, IOC, FOK)
- Order book simulation with depth
- Advanced order types (iceberg, TWAP, VWAP)
- Execution analytics and metrics
- Multi-venue routing
- Real market data integration
- Slippage based on volatility
- Liquidity modeling

## Timeline Estimate

**Optimistic**: 4-5 weeks (all phases 1-6)
**Realistic**: 5-6 weeks (including testing and refinement)

Total: ~5-6 weeks for complete engine implementation with all order types

## Next Immediate Action

**Start with Phase 1**: Create `trading/engine/lib/types.mli` defining:

1. `market_data` type
2. `market_state` type
3. `fill_status` variant
4. `execution_report` type
5. `engine_config` type

Then write tests and implement. This creates the foundation for all subsequent phases.

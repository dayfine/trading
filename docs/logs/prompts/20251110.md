# Trading Engine Development Plan - 2025-11-10 (Revised)

## Context

After completing Portfolio and Orders modules, we're building the Trading Engine - the execution layer that acts as a simulated broker. This plan revises the original approach based on key architectural insights.

### Completed Dependencies ✅
- **Orders Module**: Full CRUD, validation, status management, OrderManager (13 tests)
- **Portfolio Module**: Lot tracking, FIFO/AverageCost, P&L calculations (42 tests)
- **Base Types**: Core domain models including `trade`, `order_type` variants

## Key Architectural Insights

### 1. Engine is a Broker, Not an Order Manager

**Wrong Approach** (original plan):
```ocaml
(* Engine manages its own orders - duplicates OrderManager *)
val execute_order : engine_config -> market_state -> order -> execution_report
```

**Right Approach**:
```ocaml
(* Engine works WITH OrderManager - separation of concerns *)
type t  (* stateful engine with internal market data *)

val process_orders : t -> order_manager -> execution_report list status_or
```

**Why**: Real brokers don't manage your order book - they execute orders. OrderManager already handles order lifecycle (submit, cancel, query). Engine just needs to:
- Query pending orders from OrderManager
- Attempt execution based on internal market state
- Update order status back in OrderManager
- Return execution reports with trades

### 2. Market Data is Internal to Engine

**Client Code Shouldn't**:
- Create or manage `market_state`
- Pass market data to every execution call
- Worry about market data storage

**Engine Should**:
- Maintain internal market state (fed by simulation)
- Use market data for execution decisions
- Expose `update_market` to receive price feeds

This matches real broker APIs - you don't send them market data, they have it.

### 3. Execution Reports Bridge to Portfolio

```
OrderManager (order lifecycle)
    ↓ orders
Engine (execution)
    ↓ execution_reports
        ↓ contains trades
Portfolio (position tracking)
```

```ocaml
let reports = Engine.process_orders engine order_mgr in
let trades = List.concat_map (fun r -> r.trades) reports in
let portfolio' = Portfolio.apply_trades portfolio trades
```

## Architecture Overview

### Component Responsibilities

**OrderManager** (`trading.orders.manager`):
- Submit orders with initial Pending status
- Cancel active orders
- Query/filter orders
- **NEW**: Update order status (needs to be added)

**Engine** (`trading.engine`):
- Maintain internal market state
- Process pending orders on demand
- Execute orders based on type (Market/Limit/Stop)
- Update order status in OrderManager
- Generate trades for filled orders
- Return execution reports

**Portfolio** (`trading.portfolio`):
- Apply trades from execution reports
- Track positions and P&L
- Validate trade constraints

**Simulation** (future):
- Orchestrate the flow
- Feed market data to engine
- Trigger order processing
- Apply trades to portfolio

### Data Flow

```
Simulation Loop:
  1. Submit orders → OrderManager
  2. Update market data → Engine.update_market()
  3. Process orders → Engine.process_orders(order_mgr)
     - Engine queries pending orders from order_mgr
     - Engine attempts execution with internal market data
     - Engine updates order status in order_mgr
     - Engine returns execution_reports
  4. Extract trades → List.concat_map (fun r -> r.trades)
  5. Apply to portfolio → Portfolio.apply_trades(trades)
```

## Required Changes to OrderManager

Before implementing engine, we need to add to `trading.orders.manager`:

```ocaml
val update_order : order_manager -> order -> status
(** Update an existing order. Used by execution engine to update status,
    filled_quantity, and avg_fill_price after execution. *)
```

Implementation:
```ocaml
let update_order manager order =
  if not (Hashtbl.mem manager.orders order.id) then
    error_not_found ("Order with ID " ^ order.id ^ " not found")
  else (
    Hashtbl.replace manager.orders order.id order;
    ok ()
  )
```

## Development Strategy

### Phase 1: Engine Core with Market State ✅ (DONE)

**Files Created**:
- `trading/engine/lib/types.mli` - Core types
- `trading/engine/lib/types.ml` - Implementation
- Tests and dune configs

**Types Defined**:
- `market_data` - bid/ask/last prices
- `fill_status` - Filled | PartiallyFilled | Unfilled
- `execution_report` - order_id, status, trades
- `commission_config` - per_share, minimum
- `engine_config` - configuration

**Status**: 15 tests passing ✅

### Phase 2: Add OrderManager.update_order (Week 1)

**Goal**: Enable engine to update order status

#### Files to Modify
- `trading/orders/lib/manager.mli` - Add update_order signature
- `trading/orders/lib/manager.ml` - Implement update_order
- `trading/orders/test/test_manager.ml` - Add tests

#### API Design

```ocaml
val update_order : order_manager -> order -> status
(** Update an existing order in the manager. Replaces the order with the
    same ID. Returns error if order ID doesn't exist.

    Typically called by execution engine to update:
    - status (Pending → Filled)
    - filled_quantity
    - avg_fill_price
    - updated_at timestamp (already handled by Types.update_status)
*)
```

#### Testing Strategy
- Update existing order successfully
- Update non-existent order returns NotFound
- Updated order retrieved correctly
- Timestamp updates correctly

**Success Criteria**: 4-5 new tests passing

### Phase 3: Engine with Market State Management (Week 1-2)

**Goal**: Stateful engine that maintains internal market data

#### Files to Create
- `trading/engine/lib/engine.mli` - Public interface
- `trading/engine/lib/engine.ml` - Implementation
- `trading/engine/test/test_engine.ml` - Tests

#### Public API

```ocaml
type t
(** Opaque stateful engine - contains config and internal market state *)

val create : engine_config -> t
(** Create a new engine instance with given configuration *)

val update_market :
  t ->
  symbol ->
  bid:price option ->
  ask:price option ->
  last:price option ->
  unit
(** Update market data for a symbol. Called by simulation to feed prices.
    Updates internal market state. *)

val get_market_data : t -> symbol -> market_data option
(** Query current market data for a symbol. Useful for testing/debugging. *)
```

#### Implementation

```ocaml
type t = {
  config : engine_config;
  market_state : market_state;  (* From Types *)
}

let create config = {
  config;
  market_state = Hashtbl.create (module String);
}

let update_market engine symbol ~bid ~ask ~last =
  let md = {
    symbol;
    bid;
    ask;
    last;
    timestamp = Time_ns_unix.now ();
  } in
  Hashtbl.set engine.market_state ~key:symbol ~data:md

let get_market_data engine symbol =
  Hashtbl.find engine.market_state symbol
```

#### Testing Strategy
- Create engine
- Update market data for symbols
- Retrieve market data
- Missing symbols return None
- Market data updates correctly

**Success Criteria**: 8-10 tests passing

### Phase 4: Market Order Execution (Week 2-3)

**Goal**: Execute market orders, update OrderManager, generate trades

#### Extend Engine Module

```ocaml
(* In engine.mli *)
val process_orders : t -> order_manager -> execution_report list status_or
(** Process pending orders from the order manager.

    For each pending order:
    1. Check if execution is possible (market data available, price conditions met)
    2. If executable, generate trade and update order status to Filled
    3. If not executable, leave as Pending (limit/stop not triggered)

    Returns list of execution reports for all processed orders.
    Only includes reports for orders that changed state or attempted execution.
*)
```

#### Implementation Strategy

```ocaml
(* Private helper: Execute single market order *)
let _execute_market_order engine order =
  (* 1. Get market data *)
  let%bind market_data =
    match get_market_data engine order.symbol with
    | None -> error_not_found "No market data for symbol"
    | Some md -> Ok md
  in

  (* 2. Get execution price (last price for market orders) *)
  let%bind exec_price =
    match market_data.last with
    | None -> error_not_found "No last price available"
    | Some p -> Ok p
  in

  (* 3. Calculate commission *)
  let commission =
    Float.max
      (order.quantity *. engine.config.commission.per_share)
      engine.config.commission.minimum
  in

  (* 4. Generate trade *)
  let trade = {
    id = "trade_" ^ order.id;  (* Simple ID for now *)
    order_id = order.id;
    symbol = order.symbol;
    side = order.side;
    quantity = order.quantity;
    price = exec_price;
    commission;
    timestamp = Time_ns_unix.now ();
  } in

  (* 5. Create execution report *)
  Ok {
    order_id = order.id;
    status = Filled;
    filled_quantity = order.quantity;
    remaining_quantity = 0.0;
    average_price = Some exec_price;
    trades = [trade];
    timestamp = Time_ns_unix.now ();
  }

let process_orders engine order_mgr =
  (* Get all pending orders *)
  let pending =
    OrderManager.list_orders ~filter:ActiveOnly order_mgr
  in

  (* Process each order *)
  let reports = List.filter_map pending ~f:(fun order ->
    match order.order_type with
    | Market ->
        (match _execute_market_order engine order with
        | Ok report ->
            (* Update order in manager *)
            let filled_order =
              order
              |> Types.update_status Filled
              (* TODO: also update filled_quantity, avg_fill_price *)
            in
            let _ = OrderManager.update_order order_mgr filled_order in
            Some report
        | Error _ -> None)  (* Skip failed executions *)
    | Limit _ | Stop _ | StopLimit _ ->
        None  (* Not implemented yet *)
  ) in
  Ok reports
```

#### Testing Strategy
- Market order with available market data executes
- Market order without market data fails gracefully
- Order status updated to Filled in manager
- Trade generated with correct price/commission
- execution_report contains trade
- Multiple market orders process correctly

**Success Criteria**: 15-20 tests passing

### Phase 5: Limit Order Execution (Week 3-4)

**Goal**: Add limit order execution logic

#### Extend Implementation

```ocaml
(* Private: Check if limit order can execute *)
let _can_execute_limit_order market_data order limit_price =
  match order.side with
  | Buy ->
      (* Buy limit: execute if ask <= limit price *)
      (match market_data.ask with
      | Some ask -> ask <= limit_price
      | None -> false)
  | Sell ->
      (* Sell limit: execute if bid >= limit price *)
      (match market_data.bid with
      | Some bid -> bid >= limit_price
      | None -> false)

let _execute_limit_order engine order limit_price =
  let%bind market_data = (* ... *) in

  if not (_can_execute_limit_order market_data order limit_price) then
    (* Return Unfilled report, don't update order *)
    Ok {
      order_id = order.id;
      status = Unfilled;
      filled_quantity = 0.0;
      remaining_quantity = order.quantity;
      average_price = None;
      trades = [];
      timestamp = Time_ns_unix.now ();
    }
  else
    (* Execute at limit price (or better) *)
    let exec_price = match order.side with
      | Buy -> Float.min limit_price (Option.value_exn market_data.ask)
      | Sell -> Float.max limit_price (Option.value_exn market_data.bid)
    in
    (* Generate trade and report... *)
```

#### Update process_orders

```ocaml
let process_orders engine order_mgr =
  let pending = OrderManager.list_orders ~filter:ActiveOnly order_mgr in
  let reports = List.filter_map pending ~f:(fun order ->
    match order.order_type with
    | Market -> (* ... existing ... *)
    | Limit limit_price ->
        (match _execute_limit_order engine order limit_price with
        | Ok report when report.status = Filled ->
            let filled_order = Types.update_status order Filled in
            let _ = OrderManager.update_order order_mgr filled_order in
            Some report
        | Ok report -> Some report  (* Unfilled - include in results but don't update *)
        | Error _ -> None)
    | Stop _ | StopLimit _ -> None
  ) in
  Ok reports
```

#### Testing Strategy
- Buy limit fills when ask <= limit
- Sell limit fills when bid >= limit
- Buy limit unfilled when ask > limit
- Sell limit unfilled when bid < limit
- Price improvement (execute at better price)
- Order status updated only when filled
- Mixed market and limit orders

**Success Criteria**: 30-35 cumulative tests passing

### Phase 6: Stop Order Execution (Week 4-5)

**Goal**: Add stop order execution (triggers then becomes market order)

#### Extend Implementation

```ocaml
let _should_trigger_stop market_data order stop_price =
  match market_data.last with
  | None -> false
  | Some last_price ->
      match order.side with
      | Buy -> last_price >= stop_price   (* Buy stop triggers when price rises *)
      | Sell -> last_price <= stop_price  (* Sell stop triggers when price falls *)

let _execute_stop_order engine order stop_price =
  let%bind market_data = (* ... *) in

  if not (_should_trigger_stop market_data order stop_price) then
    (* Not triggered - leave pending *)
    Ok {
      order_id = order.id;
      status = Unfilled;
      (* ... *)
    }
  else
    (* Triggered - execute as market order at last price *)
    let exec_price = Option.value_exn market_data.last in
    (* Generate trade... *)
```

#### Testing Strategy
- Buy stop triggers when last >= stop_price
- Sell stop triggers when last <= stop_price
- Stop orders remain pending when not triggered
- Triggered stops execute at last price
- All three order types work together

**Success Criteria**: 45-50 cumulative tests passing

### Phase 7: Portfolio Integration Testing (Week 5)

**Goal**: End-to-end integration with Portfolio

#### Integration Test File
- `trading/engine/test/test_integration.ml`

#### Test Scenarios

```ocaml
(* Full workflow test *)
let test_end_to_end_market_order_with_portfolio _ =
  (* Setup *)
  let portfolio = Portfolio.create ~initial_cash:10000.0 () in
  let order_mgr = OrderManager.create () in
  let engine = Engine.create test_config in

  (* Create and submit order *)
  let order = create_test_order ~order_type:Market ~side:Buy ~quantity:100.0 in
  let _ = OrderManager.submit_orders order_mgr [order] in

  (* Update market *)
  Engine.update_market engine "AAPL" ~bid:(Some 150.0) ~ask:(Some 150.5) ~last:(Some 150.2);

  (* Process orders *)
  let reports = assert_ok (Engine.process_orders engine order_mgr) in
  assert_equal 1 (List.length reports);

  (* Extract trades *)
  let trades = List.concat_map reports ~f:(fun r -> r.trades) in

  (* Apply to portfolio *)
  let portfolio' = assert_ok (Portfolio.apply_trades portfolio trades) in

  (* Verify portfolio state *)
  assert_float_equal 8499.8 (Portfolio.get_cash portfolio');  (* 10000 - (100*150.2) - commission *)

  (* Verify order status *)
  let order' = assert_ok (OrderManager.get_order order_mgr order.id) in
  assert_bool "Order should be filled" (Types.is_filled order')
```

#### Test Coverage
- Market order: submit → execute → portfolio update
- Limit order: submit → wait → trigger → portfolio update
- Stop order: submit → monitor → trigger → portfolio update
- Insufficient cash rejection by portfolio
- Order remains pending when limit not met
- Multiple orders in sequence

**Success Criteria**: 60-65 cumulative tests passing

## Implementation Guidelines

### TDD Workflow (Per Phase)
1. **Design**: Write `.mli` interface with detailed comments
2. **Stub**: Create minimal `.ml` with unimplemented functions
3. **Test**: Write comprehensive tests (red phase)
4. **Implement**: Make tests pass incrementally (green phase)
5. **Review**: Self-critique, refactor, handle edge cases
6. **Format**: `dune fmt`
7. **Commit**: Clear, focused commit message

### Code Quality Standards
- [ ] All public functions documented in `.mli`
- [ ] Use Result types for fallible operations
- [ ] Prefix internal helpers with `_`
- [ ] Exhaustive pattern matching on variants
- [ ] Use Matchers library in tests
- [ ] Descriptive error messages
- [ ] No magic numbers

### Common Patterns

**Variant Dispatch**:
```ocaml
let process_orders engine order_mgr =
  let pending = OrderManager.list_orders ~filter:ActiveOnly order_mgr in
  List.filter_map pending ~f:(fun order ->
    match order.order_type with
    | Market -> _execute_market_order engine order
    | Limit price -> _execute_limit_order engine order price
    | Stop price -> _execute_stop_order engine order price
    | StopLimit _ -> None  (* Not implemented *)
  )
```

**Error Handling**:
```ocaml
let _execute_market_order engine order =
  let open Result.Let_syntax in
  let%bind market_data = _get_market_data engine order.symbol in
  let%bind exec_price = _extract_last_price market_data in
  let commission = _calculate_commission engine.config order.quantity in
  let trade = _generate_trade order exec_price commission in
  return (_create_filled_report order trade)
```

## Success Metrics

### Phase Completion
- [x] Phase 1: Types module (15 tests) ✅
- [ ] Phase 2: OrderManager.update_order (5 tests)
- [ ] Phase 3: Engine with market state (10 tests)
- [ ] Phase 4: Market order execution (20 tests)
- [ ] Phase 5: Limit order execution (35 cumulative)
- [ ] Phase 6: Stop order execution (50 cumulative)
- [ ] Phase 7: Portfolio integration (65 cumulative)

### Overall Success
- [ ] All 7 phases complete
- [ ] 65+ tests passing
- [ ] Engine works with OrderManager (not duplicating it)
- [ ] Market data internal to engine
- [ ] execution_reports flow to Portfolio
- [ ] Zero compilation warnings
- [ ] Code formatted with `dune fmt`

## Known Challenges & Solutions

1. **Trade ID Generation**: Need deterministic IDs for testing
   - Solution: Accept optional `~id_generator:unit -> string` parameter

2. **Timestamp in Tests**: Need consistent timestamps
   - Solution: Accept optional `~timestamp:Time_ns_unix.t` parameter

3. **OrderManager.update_order**: Needs to be added first
   - Solution: Phase 2 explicitly adds this before engine implementation

4. **Commission Calculation**: Rounding and edge cases
   - Solution: Clear formula: `max(qty * per_share, minimum)`

5. **Partial Fills**: Complex for initial version
   - Solution: Phase 1-7 use full fills only, add partials later

## Future Enhancements (Post-MVP)

- Partial fills for large orders
- StopLimit order support
- Time-in-force handling (Day, IOC, FOK)
- Market impact modeling
- Order book depth simulation
- Execution quality metrics
- Real-time event streaming
- Multi-venue routing

## Timeline Estimate

**Optimistic**: 4-5 weeks
**Realistic**: 5-6 weeks

## Next Immediate Steps

1. **Phase 2**: Add `update_order` to OrderManager
2. **Phase 3**: Implement stateful engine with market state
3. **Phase 4**: Add market order execution

Let's begin with Phase 2: updating the OrderManager module.
